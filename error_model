#%%
import numpy as np
from scipy.stats import unitary_group
import strawberryfields as sf
from strawberryfields.ops import *

# def is_unitary(matrix):
#     conjugate_transpose = matrix.conjugate().transpose()
#     return np.allclose(conjugate_transpose, np.linalg.inv(matrix))

# def apply_random_deviations(matrix, stddev):
#     '''Takes input unitary matrix and applies deviation to each element (real & imaginary
#     based on a normal distribution with input stddev'''
#     if not is_unitary(matrix):
#         raise ValueError("The input matrix is not unitary.")
#     deviation_array = np.random.normal(scale=stddev, size=matrix.shape).astype(complex)
#     deviated_arr = matrix + deviation_array
#     deviation_array_imag = np.random.normal(scale=stddev, size=matrix.shape).astype(complex)
#     return deviated_arr + deviation_array_imag * 1j


# arr = np.array([[1+2j, 3+4j], [5+6j, 7+8j]])
# A = ideal_matrix = unitary_group.rvs(2) #doesn't give symmetric matrix( only unitary)
# print(A)
# deviated_arr = apply_random_deviations(A, 0.1)

# print(deviated_arr)
#%% 

U = unitary_group.rvs(4)
print(U)

boson_sampling = sf.Program(4)
eng = sf.Engine("fock", backend_options={"cutoff_dim": 6})

with boson_sampling.context as q:
    # prepare the input fock states
    Fock(1) | q[0]
    Fock(1) | q[1]
    Fock(1) | q[2]
    Fock(1) | q[3]
    Interferometer(U) | q

#%% Continue here
import cmath


a = sf.decompositions.rectangular(U) #decompose unitary U into BS,Rgates, diagonal V in centre
boson_sampling.compile(compiler="fock").print()

print('T_i = ',a[0])
print('V =', a[1])
print('T=', a[2])

V_comp = a[1]

r1,phi1 = cmath.polar(V_comp[2]) #express V components from complex number to polar angle
#r component is always 1 for these, so only need angle to put to exponential. That exponential
#is the Rgate angle
print(phi1)# so this would be Rgate(phi1) | q[0]
#%%%
def diag_matrix_rotations(D_comp):
    '''
    D_comp == list of matrix diagonal components of diagonal matrix
    '''
    angles = []
    for i in D_comp:
        _,phi = cmath.polar(i)
        if phi < 0 :
            phi = 2*np.pi + phi
        angles.append(phi )
    return angles

new_a = [a[0], diag_matrix_rotations(a[1]), a[2] ] # won't need this
T = a[0]
V = diag_matrix_rotations(a[1])
T_dash = a[2]

# %% build circuit out of new_a

N = T[0][-1] #number of modes
noisy = sf.Program(N)
eng = sf.Engine("fock", backend_options={"cutoff_dim": 6})

with noisy.context as q:
    for i in range(N):
        Fock(1) | q[i]
    for row in T: #j is a row in T
        Rgate(row[3]) | q[row[0]]
        BSgate(row[2], 0) | (q[row[0]], q[row[1]])
    for j in range(len(V)):
        Rgate(V[j]) | q[j]
    for row in reversed(T_dash): #take the last row first
        BSgate(-row[2],0) | (q[row[0]], q[row[1]])
        Rgate(-row[3]) | q[row[0]]

noisy.compile(compiler="fock").print()


# %%
