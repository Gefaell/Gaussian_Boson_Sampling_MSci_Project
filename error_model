#%%
import numpy as np
from scipy.stats import unitary_group
import strawberryfields as sf
from strawberryfields.ops import *

def is_unitary(matrix):
    conjugate_transpose = matrix.conjugate().transpose()
    return np.allclose(conjugate_transpose, np.linalg.inv(matrix))

def apply_random_deviations(matrix, stddev):
    '''Takes input unitary matrix and applies deviation to each element (real & imaginary
    based on a normal distribution with input stddev'''
    if not is_unitary(matrix):
        raise ValueError("The input matrix is not unitary.")
    deviation_array = np.random.normal(scale=stddev, size=matrix.shape).astype(complex)
    deviated_arr = matrix + deviation_array
    deviation_array_imag = np.random.normal(scale=stddev, size=matrix.shape).astype(complex)
    return deviated_arr + deviation_array_imag * 1j


arr = np.array([[1+2j, 3+4j], [5+6j, 7+8j]])
A = ideal_matrix = unitary_group.rvs(2) #doesn't give symmetric matrix( only unitary)
print(A)
deviated_arr = apply_random_deviations(A, 0.1)

print(deviated_arr)
#%% 

U = unitary_group.rvs(4)
print(U)
#%%
boson_sampling = sf.Program(4)
eng = sf.Engine("fock", backend_options={"cutoff_dim": 6})

with boson_sampling.context as q:
    # prepare the input fock states
    Fock(1) | q[0]
    Fock(1) | q[1]
    Vac     | q[2]
    Fock(1) | q[3]

    Interferometer(U) | q


boson_sampling.compile(compiler="fock").print()


circuit = boson_sampling.compile(compiler = 'fock')



params = boson_sampling.compile(compiler="fock").params('')
print(params)

loss_sampling = sf.Program(len(U))

with loss_sampling.context as q:
    circuit
    MeasureFock() | q[0]

# params_new = loss_sampling.draw_circuit()

results = eng.run(loss_sampling)
# print(results.samples[0][0])

#%%

prog = sf.Program(3)

with prog.context as q:
    Sgate(0.54) | q[0]
    Sgate(0.54) | q[1]
    Sgate(0.54) | q[2]
    BSgate(0.43, 0.1) | (q[0], q[2])
    BSgate(0.43, 0.1) | (q[1], q[2])
    MeasureFock() | q


